---
title: "Lecture 4: Generating 2D graphics with R"
date: "October 12, 2016"
output: 
  revealjs::revealjs_presentation:
    self_contained: false
    lib_dir: libs
    theme: simple
    hightlights: haddock
    smart: true
    center: true
    transition: slide
    css: cme195.css
    fig_width: 10
    fig_height: 6
    reveal_options:
      slideNumber: true
---

```{r setup, include=FALSE, echo = FALSE}
options(width = 80)
knitr::opts_chunk$set(cache = TRUE, tidy = FALSE, size = "small")
reqpkg <- c("ggplot2", "ggrepel", "gridExtra", "dplyr")
sapply(reqpkg, require, character.only = TRUE)
```

## Contents 

* Intro to `ggplot2` package
* Comparison with base-graphics
* Geometric objects and aesthetics
* Statistical transformations
* Scales
* Faceting

## Installation

```{r check-install-load-packages, warning=FALSE, message=FALSE, eval = FALSE}
install.packages("ggplot2")
install.packages("ggrepel")
install.packages("gridExtra")
library(ggplot2)
library(ggrepel)
library(gridExtra)
```


# Intro to `ggplot2` package

## What is `ggplot2`?

> "`ggplot2` is **a plotting system for R, based on the grammar of graphics**. 
It takes care of many of the fiddly details that make plotting a hassle 
(like drawing legends) as well as providing a powerful model of graphics 
that makes it easy to produce complex multi-layered graphics"[1]. 

<footer> [1] http://ggplot2.org/ </footer>

## Advantages of `ggplot2`

* Graphics are defined at **a high level of abstraction**.
* Plots are broken down into **layers**.
* The package is **flexible** and offers extensive **customization** options.
*  The **documentation** is well-written. 
* `ggplot2` has a large user base => **it's easy find to help**.

## Weaknesses of `ggplot2`

You should not or cannot use `ggplot2` for:

* 3D graphics
    - use [`rgl`](https://cran.r-project.org/web/packages/rgl/vignettes/rgl.html)  or [`ggplot2` + `plotly`](http://blog.revolutionanalytics.com/2014/11/3-d-plots-with-plotly.html)
instead,
* graph/network plots with nodes and edges
    - use [`igraph`](http://igraph.org/r/) instead
* interactive graphics: 
    - use [`ggvis`](http://ggvis.rstudio.com/ggvis-basics.html), 
[`plotly`](https://github.com/ropensci/plotly) instead


## What is a grammar of graphics?

* It is a concept **coined by Leland Wilkinson in 2005**.
* An **abstraction** which facilitates reasoning and communicating graphics.
* `ggplot2` is **a layered grammar of graphics** which allow users to

 *independently specify the building blocks of a plot and combine them to 
create just about any kind of graphical display*


## Building blocks of a `ggplot2` graphs

* data
* aesthetic mapping
* geometric objects
* statistical transformations
* scales
* coordinate system
* positioning adjustments
* faceting

## `ggplot()` function

* `ggplot()` is used to **initialize the basic graph structure**.
* It **cannot produce a plot** alone by itself. 
* Instead, we need to **add extra components** to generate a graph. 
* You need to **specify different parts** of a plot, 
and *add them all together* using an `+` operator.


## The structure of ggplot object

<div style = "font-size: 36px">
```{r ggplot-structure, eval = FALSE}
ggplot(data = <default data set>, 
       aes(x = <default x axis variable>,
           y = <default y axis variable>,
           ... <other default aesthetic mappings>),
       ... <other plot defaults>) +
  
  geom_<geom type>(aes(size = <size variable for this geom>, 
                       ... <other aesthetic mappings>),
                   data = <data for this point geom>,
                   stat = <statistic string or function>,
                   position = <position string or function>,
                   color = <"fixed color specification">,
                  ... <other arguments, possibly passed to the _stat_ function) +

  scale_<aesthetic>_<type>(name = <"scale label">,
                           breaks = <where to put tick marks>,
                           labels = <labels for tick marks>,
                           ... <other options for the scale>) +

  theme(plot.background = element_rect(fill = "gray"),
        ... <other theme elements>)
```
</div>

# Comparison with base-graphics

## ggplot2 compared to base graphics is

* more verbose for **simple / out of the box** graphics
* less verbose for **complex / custom** graphics
* uses a different system for **adding plot elements**
instead of calling new functions.
* more details on why to use `ggplot2` over base plot 
can be found in this
[blog](http://varianceexplained.org/r/why-I-use-ggplot2/).


## Example 1: History of unemployment

`ggplot2` has a built-in **`economics`** dataset, which inclides
time series data on US unemployment from 1967 to 2015.

```{r, fig.width=10, fig.height=6}
economics
economics <- mutate(economics, unemp_rate = unemploy/pop)
```

## R base graphics

```{r}
plot(unemploy/pop ~ date, data = economics,  type = "l")
```

## `ggplot2` package

```{r}
library(ggplot2)
ggplot(data = economics, aes(x = date, y = unemp_rate)) + geom_line()
```

## ggplot() by itself does not plot the data
```{r}
ggplot(data = economics, aes(x = date, y = unemp_rate))
```

## You need to add a line-layer

```{r}
ggplot(data = economics, aes(x = date, y = unemp_rate)) + geom_line()
```

## Change the background color to white

```{r}
ggplot(data = economics, aes(x = date, y = unemp_rate)) + 
  geom_line() + theme_bw()
```

## What about comparing 2009 to 2014?

```{r}
# Add new variables for plotting
economics <- economics %>% 
  mutate(month =  as.numeric(format(date, format="%m")),
         year = as.numeric(format(date, format="%Y")))
economics %>% select(date, month, year, unemp_rate)
```

## Using base graphics

<div style = "font-size: 36px">

```{r}
data09 <- subset(economics, year == 2009)
data14 <- subset(economics, year == 2014)
plot(unemp_rate ~ month, data = data09, ylim = c(0.025, 0.05), type = "l")
lines(unemp_rate ~ month, data = data14, col = "red")
legend("topleft", c("2009", "2014"), col = c("black", "red"), lty = c(1,1))
```
</div>

## Using ggplot2

```{r}
data2009_2014 <- subset(economics, year %in% c(2014, 2009))
ggplot(data = data2009_2014, aes(x = month, y = unemp_rate)) + 
  geom_line(aes(group = year, color = year)) # No need to specify a legend
```

## 

```{r}
ggplot(data = data2009_2014, aes(x = factor(month), y = unemp_rate)) + 
  geom_line(aes(group = year, color = factor(year))) 
```


## Plotting all the years together is easy

```{r}
ggplot(data = economics, aes(x = month, y = unemp_rate)) + 
  geom_line(aes(group = year, color = factor(year))) +
    theme(axis.text.x = element_text(angle = 45))
```

## Example 2: diamonds dataset

The dataset contains the prices and other attributes of almost 54,000 
diamonds. You can call `?diamonds` to learn more about the available attributes.

```{r}
diamonds
```

## Distribution of the diamonds prices with base graphics

```{r}
hist(diamonds$price)
```

##

```{r}
# breaks can be a vector, a function or a single number
hist(diamonds$price, breaks = 5)
```

## Histograms with ggplot2

```{r}
ggplot(diamonds, aes(x = price)) + geom_histogram()
```


```{r}
# you can set bins= or binwidths = 
ggplot(diamonds, aes(x = price)) + geom_histogram(bins = 5)
```


## Subset the data

* We select a random subset of the data to use for plotting
the relationship between the weights (carat = 200 mg) 
and prices ($) of diamonds 

```{r}
set.seed(12345) # Make the sample reproducible
dsmall <- diamonds[sample(nrow(diamonds), 200), ]
```

## Scatter plot with base graphics



```{r}
colorMap <- data.frame(row.names = unique(dsmall$color),
                       color = rainbow(length(unique(dsmall$color))))
plot(price ~ carat, data = dsmall, col = colorMap[dsmall$color, "color"])
legend(x = 'bottomright', legend = rownames(colorMap), col = colorMap$color, pch = 1)
```

## Scatter plot with ggplot2

```{r}
ggplot(data = dsmall, aes(x = carat, y = price, color = color)) + 
  geom_point()
```


# Geometric objects and aesthetics

## Geometic objects - actual items on the plot

* points (`geom_point()`, used for scatter plots)
* lines (`geom_line()`, used for time series, trend lines, etc.)
* boxplot (`geom_boxplot()` used for, well, boxplots!)

There is no upper limit to how many geom objects you can use.
You can add a geom objects to a plot using an `+` operator.

To get a list of available geometric objects use the following:

```{r}
help.search("geom_", package = "ggplot2")
```


## Aesthetic mapping

* In ggplot an **aesthetic mapping**, defined with aes(), describes how 
variables are mapped to visual properties or aesthetics.
* For example, we might map weight to x weigth, height to y price,
and cut to color for the diamonds dataset.
* The details of the mapping are described by the scales.

## Examples of aesthetics are: 

* position (i.e., on the x and y axes)
* shape 
* linetype
* size
* color ("outside" color)
* fill ("inside" color)


Each type of geom objects accepts only a subset of aesthetics. 

Refer to the geom help pages to see what mappings each geom accepts. 

## Scatter plots with geom_points

```{r}
p1 <- ggplot(dsmall, aes(x = carat, y = price))
p1 + geom_point()
```

## Color points 

```{r}
# color by diamonds color
p1 + geom_point(aes(color = color))
```

## Set the shape of the points 

```{r}
# set shape by diamond cut
p1 + geom_point(aes(shape = cut))
```

## Set color and shape

```{r}
p1 + geom_point(aes(shape = cut, color = color))
```

## Variable vs fixed aesthetics

```{r}
ggplot(data = dsmall, aes(x = carat, y = price)) + 
  geom_point(aes(size = 2), color = "darkgreen") 
```

## 

```{r}
ggplot(data = dsmall, aes(x = carat, y = price)) + 
  geom_point(aes(fill = cut), size = 2, color = "black", shape = 25)
```


## All 25 shape configurations

```{r}
ggplot(data.frame(x = 1:5 , y = 1:25, z = 1:25), aes(x = x, y = y)) +
  geom_point(aes(shape = z), size = 5, colour = "darkgreen", fill = "orange") +
  scale_shape_identity()
```


## Data transformations

```{r}
ggplot(dsmall, aes(x = log(carat), y = log(price))) + geom_point()
```

## Text labels

```{r}
p2 <- ggplot(dsmall, aes(x = log(carat), y = log(price)))
p2 + geom_text(aes(label = color))
```

## Text with rectangle plates

```{r}
p2 + geom_label(aes(label = color))
```

## ggrepel package for annotation

`ggrepel` helps annotating **overlapping labels**.

```{r}
library(ggrepel)
p2 + geom_point() + geom_text_repel(aes(label=color), size = 3)
```

## Exercise 1


* Go to "Lec4_Exercises.Rmd" on the class website.

* Complete Exercise 1.


# Statistical Transformations

## Types of statistical transformations

Plots often require some statistical data transformation or computation
before they can be plotted:
 
* **boxplots:** the the median, lower and upper quartiles, 
* **histograms:** group the values into bins, 
* **smoothers:** prediction lines / predicted y-values,
* **bar charts:** number of class occurrences. 

## Jittered points

```{r}
ggplot(data = diamonds, aes(x = color, y =price/carat)) +
  geom_jitter()
```

## Alpha parameter for transparency

<div style = "font-size: 36px">
```{r fig.height=5, fig.width=15}
j1 <- ggplot(data = diamonds, aes(x = color, y = price/carat)) + geom_jitter(alpha = 1/5)
j2 <- ggplot(data = diamonds, aes(x = color, y = price/carat)) + geom_jitter(alpha = 1/50)
j3 <- ggplot(data = diamonds, aes(x = color, y = price/carat)) + geom_jitter(alpha = 1/200)
# We use grid.arrange from gridExtra to display multiple plots
grid.arrange(j1, j2, j3, ncol = 3)
```
</div>

## Box plot transformation

Plotting a summary (less data) can be more insightful.

```{r}
ggplot(data = diamonds, aes(x = color, y =price/carat)) +
  geom_boxplot()
```

## Histogram and density plots

```{r fig.height=5, fig.width=15}
# Distribution of the carats (weights) of the diamonds.
h <- ggplot(data = diamonds, aes(x = carat)) + geom_histogram()
d <- ggplot(data = diamonds, aes(x = carat)) + geom_density()
grid.arrange(h, d, ncol = 2)
```

## 


* For the histogram, the smoothness is controlled with **`bins`** and 
**`binwidth`** arguments. (Break points can also be specified explicitly, 
using the **`breaks`** argument.) 

* For the density plot, the **`bw`** (the smoothing bandwidth) and 
**`adjust`** argument controls **the degree of smoothness**
(high values of adjust produce smoother plots). 

<!-- It is very important to experiment with the level of smoothing. With a histogram -->
<!-- you should try many bin widths: You may find that gross features of the data -->
<!-- show up well at a large bin width, while finer features require a very narrow -->
<!-- width. -->


##

```{r fig.height=5, fig.width=15, warning = FALSE}
p <- ggplot(data = diamonds, aes(x = carat)) + xlim(0, 3)
h1 <- p + geom_histogram(binwidth = 0.5) 
h2 <- p + geom_histogram(binwidth = 0.1) 
h3 <- p + geom_histogram(binwidth = 0.05) 
grid.arrange(h1, h2, h3, ncol = 3)
```

##

```{r fig.height=5, fig.width=15, warning = FALSE}
d1 <- p + geom_density(adjust = 5) 
d2 <- p + geom_density(adjust = 1) 
d3 <- p + geom_density(adjust = 1/5) 
grid.arrange(d1, d2, d3, ncol = 3)
```

## Histograms for separate groups

```{r fig.height=5, fig.width=15, warning=FALSE}
# Here we show grouping by diamonds cut.
h <- p + geom_histogram(aes(fill = cut), position = "dodge", bins = 10)
d <- p + geom_density(aes(color = cut))
grid.arrange(h, d, ncol = 2)
```

## 

Instead of marginal distributions, we can plot distribution of components
**stacked** on top of each other to see the contribution from each of group.

```{r fig.height=5, fig.width=15, warning=FALSE}
h <- p + geom_histogram(aes(fill = cut), position = "stack")
d <- p + geom_density(aes(fill = cut), position = "stack")
grid.arrange(h, d, ncol = 2)
```

## Bar charts

* A discrete analogue of a histogram is the bar chart, `geom_bar()`.

* Instead of partitioning the values into bins like histograms, the bar
geom **counts the number of instances of each discrete class**. The counts
are then plotted as columns for each distinct class.

* If you’d like include **unequal weights** for different observations, 
you can use the `weight` aesthetic. 

##
<div style = "font-size: 36px">
```{r fig.height=5, fig.width=15}
b1 <- ggplot(diamonds, aes(x = color)) + geom_bar()
b2 <- ggplot(diamonds, aes(x = color)) + geom_bar(aes(weight = carat)) + ylab("carat")
grid.arrange(b1, b2, ncol = 2)
```
</div>

The left plot shows the number of diamonds in each color group, and 
the right plot shows the count weighted by carat, which is equivalent 
to showing the total weight of diamonds in each color group.


## 

* As you see, in `ggplot2` (unlike base graphics)
it is **not necessary tabulate the values**, i.e. compute the counts of each 
category beforehand. The computation is done automatically for you.

* However, if you have already summarized data, you can still use
`geom_bar` but you need to specify an identity transformation, `stat = "identity`
rather than the default `stat = "count"`.

```{r}
diamond.counts <- table(diamonds["color"])
df <- data.frame(diamond.counts)
colnames(df) <- c("color", "count")
df
```


##


```{r eval = FALSE}
# The default option generates an error:
ggplot(df, aes(x=color, y=count)) +  geom_bar()
# Error: stat_count() must not be used with a y aesthetic.
```

```{r}
# You need to do the following:
ggplot(df, aes(x=color, y=count)) +  geom_bar(stat="identity")
```


## Regression lines

<div style = "font-size: 36px">
```{r}
# You can fit a linear model with lm(y ~ x, data) and use it for prediction.
dsmall$pred.price <- predict(lm(price ~ carat, data = dsmall))
# And add the regression line in a standard way
p1 <- ggplot(dsmall, aes(x = carat, y = price))
p1 + geom_point(aes(color = color)) + geom_line(aes(y = pred.price))
```
</div>

## Regression lines with ggplot2

```{r}
# Or you can simply use geom_smooth()!
p1 + geom_point(aes(color = color)) + geom_smooth(method = "lm")
```



## Smoothers are trend lines

<div style = "font-size: 36px">
```{r}
# Smoothers help discern patterns in the data
ggplot(data = diamonds, aes(x = carat, y = price)) +
  geom_point() + geom_smooth()
```
</div>

##

For the small subset of the diamonds dataset we have:

```{r}
ggplot(dsmall, aes(x = carat, y = price)) +
  geom_point() + geom_smooth()
```

##

'`span`' determines the wigglyness of the curve
(smaller `span` => more wiggly)

```{r, fig.width=14, fig.height=5.5}
grid.arrange(p1 + geom_point() + geom_smooth(span = 0.2),
             p1 + geom_point() + geom_smooth(span = 0.7), ncol = 2)
```

## 

* By default, when applied to datasets with a few observations 
(`n < 1000`) `geom_smooth()` uses a `method = "loess"` for fitting a curve. 

* This method uses a smooth local regression. More details about the algorithm
used can be found in `?loess`. 

* Loess does not work well for large datasets (it’s $O(n^2)$ in memory), and so
an alternative smoothing algorithm is used when n is greater than 1,000.


## Exercise 2: The Economist Data 

* Go back to "Lec4_Exercises.Rmd"

* Complete the exercise 2


# Scales

## Aesthetic mapping vs variable scaling

* `aes()` is responsible for assigning an aesthetic to a variable; it doesn't 
determine how mapping should be done. 
* For example, `aes(shape = x)` or `aes(color = z)` do not specify what shapes
or what colors should be used. To choose colors/shapes/sizes etc. you need
to **modify the corresponding scale**. 
* `ggplot2` includes scales for:
    + position
    + color and fill
    + size
    + shape
    + line type

## 
Scales can be modified with functions of the form:
`scale_<aesthetic>_<type>()`, e.g. `scale_color_discrete()`.
</br>

Try typing `scale_<tab>()` to see a list of scale modification functions.
</br>

>- **Common Scale Arguments:**

> - **name**: the first argument gives the axis or legend title
> - **limits**: the minimum and maximum of the scale
> - **breaks**: the points along the scale where labels should appear
> - **labels**: the labels that appear at each break

## Scale for axes

```{r fig.height=5, fig.width=14}
# Square root y-axis transformation
p1 <- ggplot(dsmall, aes(x = carat, y = price)) + geom_point()  
psqrt <- p1 + scale_y_sqrt()
# Log base 10 y-axis transformation
plog10 <- p1 + geom_point() + scale_y_log10()
grid.arrange(psqrt, plog10, ncol = 2)
```


##

Log base 10 transformation of x and y axes. Note the differences.

```{r fig.height=5, fig.width=14}
ploglog1 <- p1 + geom_point() + scale_y_log10() + scale_x_log10()
ploglog2 <- ggplot(dsmall, aes(x = log(carat), y = log(price))) + geom_point()
grid.arrange(ploglog1, ploglog2, ncol = 2)
```


## Scale for shapes

<div style = "font-size: 36px">
```{r fig.width = 14, fig.height = 5}
p11 <- p1 + geom_point(aes(shape = cut), size = 3)  
p12 <- p1 + geom_point(aes(shape = cut), size = 3) + scale_shape_manual(values = c(1:5))
grid.arrange(p11, p12, ncol = 2)
```
</div>

## Scale for colors

To choose specific colors for **discrete** variables we use `scale_color_manual`.

```{r}
p1 + geom_point(aes(color = cut), size = 3) + 
  scale_color_manual(values = c("red", "orange", "yellow", "green", "blue"))
```

## 

For **continuous** variables we use `scale_color_gradient`, and specify
the ends of the color spectrum.

```{r}
p1 + geom_point(aes(color = price), size = 3) + 
  scale_color_gradient(low = "blue", high = "red")
```

##

`scale_color_brewer` lets you choose **nice color palettes for discrete variables**.

```{r}
p1 + geom_point(aes(color = cut), size = 3) + 
  scale_color_brewer(palette = "Set2")
```

##

Unfortunately, `scale_color_brewer` doesn't work for continuous variables:

```{r eval = FALSE}
# scale_color_brewer() does not work with continuous variables 
# and will result in an error
p1 + geom_point(aes(shape = price), size = 3) + 
  scale_color_brewer(palette = "Spectral")
# Error: A continuous variable can not be mapped to shape
```

We can get around this issue using the `RColorBrewer` package
and `scale_color_gradientn` function, which **interpolates colors**
from the brewer palettes.


## 

```{r}
# install.packages("RColorBrewer")
library(RColorBrewer)
p1 + geom_point(aes(color = price), size = 3) + 
  scale_color_gradientn(colours = brewer.pal(name = "Spectral", n = 10))
```

## 

Another popular color scheme package, `viridis`, supports both discrete
and continuous variables:

```{r, message=FALSE, warning=FALSE}
# install.packages("viridis")
library(viridis)
p1 + geom_point(aes(color = price), size = 3) + scale_color_viridis()
```

## 


```{r, message=FALSE, warning=FALSE}
p1 + geom_point(aes(color = cut), size = 3) + 
  scale_color_viridis(discrete = TRUE, option = "magma")
```


##
... there are also other unconventional schemes such as, [one
based on Wes Anderson movies](http://wesandersonpalettes.tumblr.com/) :

```{r}
#install.packages("wesanderson")
library(wesanderson)
names(wes_palettes)
```

## Wes Anderson color palette:

```{r}
# For discrete variables
p1 + geom_point(aes(color = cut), size = 3) + 
  scale_color_manual(values = wes_palette("Darjeeling", n = 5))
```

## 

```{r}
# For continuous variables:
p1 + geom_point(aes(color = price), size = 3) + 
  scale_color_gradientn(colours = wes_palette("Darjeeling", 100, type = "continuous"))
```

##

You can also **scale the values of the variable corresponding to color**.

```{r}
p1 + geom_point(aes(color = price), size = 3) + 
  scale_color_gradient(low = "blue", high = "red", trans = "log10")
```

##

Or and add your own breaks 

```{r}
p1 + geom_point(aes(color = price), size = 3) + 
  scale_color_gradient(low = "blue", high = "red", trans = "log10",
                       breaks = c(1000, 2000, 5000, 10000),
                       labels = c("  1000", "  2000", "  5000", "10000")) 
```



## Exercise 3

* Go to back "Lec4_Exercises.Rmd"

* Complete Exercise 3


# Faceting

##
**Facettng** allows you to split up your data by 
one or more variables and plot the subsets of data together.

<div style = "font-size: 36px">
```{r fig.height=5, fig.width=14, warning=FALSE, message=FALSE}
dsmall <- diamonds[sample(nrow(diamonds), 1000), ]
p0 <- ggplot(data = dsmall, aes(x = carat, y = price)) +geom_point(size = 1) +
  geom_smooth(aes(colour = cut, fill = cut)) 
p1 <- p0 + facet_wrap(~ cut)
grid.arrange(p0, p1, ncol = 2)
```
</div>

##

```{r}
ggplot(diamonds, aes(x = carat)) +
  geom_density() + 
  facet_grid(color ~ cut)
```


## Exercise 4,5

* Go to back "Lec4_Exercises.Rmd"

* Complete Exercise 4,5
