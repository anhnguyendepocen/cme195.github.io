--- 
title: 'Lecture 3:  Data Manipulation'
date: "October 10, 2017" 
output: 
  revealjs::revealjs_presentation: 
    self_contained: false
    lib_dir: libs
    css: class.css
    highlight: default 
    smart: true
    center: true
    transition: default 
    background_transition: default 
    text-align: left;
    reveal_options: 
      slideNumber: true 
      previewLinks: true 
---

```{r global_options, echo = FALSE, include = FALSE}
options(width = 999)
knitr::opts_chunk$set(warning = FALSE, message = FALSE,
                      cache = FALSE, tidy = FALSE, size = "small")
```


## Contents

* apply family functions
* Intro to `dplyr` package
* Aggregating & summarizing data
* Joining & appending datasets
* Wide & long Data 

# apply family

## apply, lapply, sapply functions

- The `apply` family functions, are 
**functions to manipulate slices of data** from matrices, 
arrays, lists and dataframes **in a repetitive way**. 

- These functions **avoid explicit use of loops**. 
`apply` might be **computationally more efficient than
for loops**, depending on how big your data is.
For more details see this 
[link](https://www.r-bloggers.com/gnu-r-loop-speed-comparison/).

- The apply functions allow you to perform operations with 
**very few lines of code.**

- The family comprises: **apply, lapply , sapply, vapply, 
mapply, rapply, and tapply**. The difference lies in the structure
of input data and the desired format of the output).


## lapply/sapply functions

<div class="left", style="width: 50%">

- `lapply()` is used to **repeatedly apply a function to 
a elements of sequential objects** such as vectors, lists, 
or data-frames (applies to columns).

- The **output returned is a list** with the same number of 
elements as the input object.

- `sapply` is the same as `lapply` but returns a "simplified" output.

- user-defined functions can be used with `sapply/lapply`

</div>

<div class="right", style="width: 50%">

```{r}
lapply(1:3, function(x) x^2)
unlist(lapply(1:3, function(x) x^2))
sapply(1:3, function(x) x^2)
sapply(1:3, function(x) x^2, simplify = F)
```

</div>

## apply function

`apply` operates on arrays/matrices. 
In the example below we obtain column sums of matrix "X".

```{r}
(X <- matrix(sample(30), nrow = 5, ncol = 6))
apply(X, MARGIN = 2 , FUN = sum)
```

**Note:** that in a matrix `MARGIN=1` indicates rows and `MARGIN=2`
indicates columns.


## apply function


<div class="left", style="width: 50%">
- `apply` can be used with **user-defined functions**:

```{r}
print(X)
apply(X, 2, function(x) sum(x < 15)) # number entries < 15
```

</div>

<div class="right", style="width: 50%">
- The function can be defined outside `apply()`,


```{r}
logColMeans <- function(x, eps = NULL) {
  if (!is.null(eps)) x <- x + eps
  return(mean(x))
}
apply(X, 2, logColMeans) 
apply(X, 2, logColMeans, eps = 0.1) 
```

</div>

 
## mapply functions


- `mapply` stands for 'multivariate' apply.  It **applies a function
to a multiple list or multiple vectors as arguments**. 
- The goal is to vectorize arguments to a function which usually 
does not accept vectors as arguments. 

```{r}
# function word() returns a string of character C repeated k times.
word <- function(C,k) paste(rep.int(C,k), collapse='')
mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
```


## Exercise 4

</br>

- Go back to "Lec2_ex.Rmd" in RStudio.

- Do Exercise 4.


# `dplyr` package


## `dplyr`

* Introduces a grammar of data manipulation
Great for data exploration and transformation
Intuitive to write and easy to read, especially when using the “chaining” syntax (covered below)
* Fast on data frames (C++) speed of C and eas of R
* Chaining

## tibbles

`tbl` structure tibble, glimpse(), tbl_df(), as.data.frame()
tbl_df creates a “local data frame”
Local data frame is simply a wrapper for a data frame that prints nicely

##

```{r}
# load packages
suppressMessages(library(dplyr))
library(hflights)

# explore data
data(hflights)
head(hflights)


# convert to local data frame
flights <- tbl_df(hflights)

# printing only shows 10 rows and as many columns as can fit on your screen
flights
# you can specify that you want to see more rows
print(flights, n=20)

# convert to a normal data frame to see all of the columns
data.frame(head(flights))
```


## `dplyr` functions

The most commonly used `dplyr` functions (or basic verbs) are:

* `filter()`, 
* `select()`, 
* `arrange()`, 
* `mutate()`, 
* `summarise()` (used jointly with `group_by()`)

The operations performed with the above functions can be done using basic R 
functions, but they would bothe require writing more lines of (ugly) code, and
be less computationally efficient.

## “Chaining” or “Pipelining”
Usual way to perform multiple operations in one line is by nesting
Can write commands in a natural order by using the %>% infix operator (which can be pronounced as “then”)

Chaining increases readability significantly when there are many commands
Operator is automatically imported from the magrittr package
Can be used to replace nesting in R commands outside of dplyr

```{r}
# nesting method to select UniqueCarrier and DepDelay columns and filter for delays over 60 minutes
filter(select(flights, UniqueCarrier, DepDelay), DepDelay > 60)
# chaining method
flights %>%
    select(UniqueCarrier, DepDelay) %>%
    filter(DepDelay > 60)

# create two vectors and calculate Euclidian distance between them
x1 <- 1:5; x2 <- 2:6
sqrt(sum((x1-x2)^2))
# chaining method
(x1-x2)^2 %>% sum() %>% sqrt()

```


## filter: Keep rows matching criteria

Base R approach to filtering forces you to repeat the data frame’s name
dplyr approach is simpler to write and read
Command structure (for all dplyr verbs):
first argument is a data frame
return value is a data frame
nothing is modified in place
Note: dplyr generally does not preserve row names


```{r}
# base R approach to view all flights on January 1
flights[flights$Month==1 & flights$DayofMonth==1, ]
# dplyr approach
# note: you can use comma or ampersand to represent AND condition
filter(flights, Month==1, DayofMonth==1)

# use pipe for OR condition
filter(flights, UniqueCarrier=="AA" | UniqueCarrier=="UA")

# you can also use %in% operator
filter(flights, UniqueCarrier %in% c("AA", "UA"))
```



## select: Pick columns by name


Base R approach is awkward to type and to read
dplyr approach uses similar syntax to filter
Like a SELECT in SQL

```{r}
# base R approach to select DepTime, ArrTime, and FlightNum columns
flights[, c("DepTime", "ArrTime", "FlightNum")]
# dplyr approach
select(flights, DepTime, ArrTime, FlightNum)

# use colon to select multiple contiguous columns, and use `contains` to match columns by name
# note: `starts_with`, `ends_with`, and `matches` (for regular expressions) can also be used to match columns by name
select(flights, Year:DayofMonth, contains("Taxi"), contains("Delay"))
```

Dropping

```{r}
# Keep country and GDP
flights %>% select(-DepTime, -ArrTime)


# Selecting and renaming in one
flights %>% select(departure_time = DepTime, FlightNum)
```


## arrange: Reorder rows

# base R approach to select UniqueCarrier and DepDelay columns and sort by DepDelay
flights[order(flights$DepDelay), c("UniqueCarrier", "DepDelay")]

```{r}
# dplyr approach
flights %>%
    select(UniqueCarrier, DepDelay) %>%
    arrange(DepDelay)
# use `desc` for descending
flights %>%
    select(UniqueCarrier, DepDelay) %>%
    arrange(desc(DepDelay))
```

## mutate: Add new variables
Create new variables that are functions of existing variables
```{r}
# base R approach to create a new variable Speed (in mph)
flights$Speed <- flights$Distance / flights$AirTime*60
flights[, c("Distance", "AirTime", "Speed")]
# dplyr approach (prints the new variable but does not store it)
flights %>%
    select(Distance, AirTime) %>%
    mutate(Speed = Distance/AirTime*60)
# store the new variable
flights <- flights %>% mutate(Speed = Distance/AirTime*60)
```


# Renaming

As illustrated in the last line of code above you can rename variables using select(). But this can also be done using rename():

Removing duplicate observations can be useful, but be careful: entire rows will be deleted. Use distinct():



```{r}
countries <- data.frame(
    expand.grid(country = c("USA", "China", "Sudan"), year = 1994:1996),
    gdp_pc = round(runif(9, 1000, 20000), 0)
    )
countries$country <- as.character(countries$country) #factor --> character
countries
# Rename GDP per capita
countries %>% rename(GDP.PC = gdp_pc)
# Unique values
countries %>% distinct(country)
```


Note that the function keeps the first non-duplicate. This is more useful when you suspect that duplicate values of the following kind have slipped into the dataset:
```{r}
countries2 <- rbind(
    data.frame(country = "USA", year = 1994, gdp_pc = 10000),
    countries
    )
countries2 

#Note that we all of a sudden have two USA 1994 observations. Delete one of them using distinct().

countries2 %>% distinct(country, year)
```


# Aggregating & summarizing data

## summarise: Reduce variables to values
Primarily useful with data that has been grouped by one or more variables
group_by creates the groups that will be operated on
summarise uses the provided aggregation function to summarise each group

summarise_each allows you to apply the same summary function to multiple columns at once
Note: mutate_each is also available

Helper function n() counts the number of rows in a group
Helper function n_distinct(vector) counts the number of unique items in that vector

Grouping can sometimes be useful without summarising

```{r}
# for each destination, show the number of cancelled and not cancelled flights
flights %>%
    group_by(Dest) %>%
    select(Cancelled) %>%
    table() %>%
    head()

```

```{r}
# base R approaches to calculate the average arrival delay to each destination
head(with(flights, tapply(ArrDelay, Dest, mean, na.rm=TRUE)))
head(aggregate(ArrDelay ~ Dest, flights, mean))
# dplyr approach: create a table grouped by Dest, and then summarise each group by taking the mean of ArrDelay
flights %>%
    group_by(Dest) %>%
    summarise(avg_delay = mean(ArrDelay, na.rm=TRUE))

# for each carrier, calculate the percentage of flights cancelled or diverted
flights %>%
    group_by(UniqueCarrier) %>%
    summarise_each(funs(mean), Cancelled, Diverted)
# for each carrier, calculate the minimum and maximum arrival and departure delays
flights %>%
    group_by(UniqueCarrier) %>%
    summarise_each(funs(min(., na.rm=TRUE), max(., na.rm=TRUE)), matches("Delay"))

# for each day of the year, count the total number of flights and sort in descending order
flights %>%
    group_by(Month, DayofMonth) %>%
    summarise(flight_count = n()) %>%
    arrange(desc(flight_count))

# rewrite more simply with the `tally` function
flights %>%
    group_by(Month, DayofMonth) %>%
    tally(sort = TRUE)


# for each destination, count the total number of flights and the number of distinct planes that flew there
flights %>%
    group_by(Dest) %>%
    summarise(flight_count = n(), plane_count = n_distinct(TailNum))
```


## Window Functions
Aggregation function (like mean) takes n inputs and returns 1 value
Window function takes n inputs and returns n values
Includes ranking and ordering functions (like min_rank), offset functions (lead and lag), and cumulative aggregates (like cummean).

```{r}
# for each carrier, calculate which two days of the year they had their longest departure delays
# note: smallest (not largest) value is ranked as 1, so you have to use `desc` to rank by largest value
flights %>%
    group_by(UniqueCarrier) %>%
    select(Month, DayofMonth, DepDelay) %>%
    filter(min_rank(desc(DepDelay)) <= 2) %>%
    arrange(UniqueCarrier, desc(DepDelay))
# rewrite more simply with the `top_n` function
flights %>%
    group_by(UniqueCarrier) %>%
    select(Month, DayofMonth, DepDelay) %>%
    top_n(2) %>%
    arrange(UniqueCarrier, desc(DepDelay))


# for each month, calculate the number of flights and the change from the previous month
flights %>%
    group_by(Month) %>%
    summarise(flight_count = n()) %>%
    mutate(change = flight_count - lag(flight_count))


# rewrite more simply with the `tally` function
flights %>%
    group_by(Month) %>%
    tally() %>%
    mutate(change = n - lag(n))
```

## Other Useful Convenience Functions

```{r}
# randomly sample a fixed number of rows, without replacement
flights %>% sample_n(5)
# randomly sample a fraction of rows, with replacement
flights %>% sample_frac(0.25, replace=TRUE)

# base R approach to view the structure of an object
str(flights)

# dplyr approach: better formatting, and adapts to your screen width
glimpse(flights)
```



# Joining & appending datasets

## 


* Wide & long Data 
