--- 
title: 'Lecture 2:  Syntax, control flow, functions'
date: "October 5, 2017" 
output: 
  revealjs::revealjs_presentation: 
    # incremental: true 
    css: "../../css/class.css" 
    highlight: default 
    smart: true
    center: true
    transition: default 
    background_transition: default 
    self_contained: false 
    fig_width: 6 
    fig_height: 4 
    text-align: left;
    reveal_options: 
      slideNumber: true 
      previewLinks: true 
---

```{r global_options, echo = FALSE, include = FALSE}
options(width = 999)
knitr::opts_chunk$set(warning = FALSE, message = FALSE,
                      cache = FALSE, tidy = FALSE, size = "small")
```

## Contents

* RStudio
* Syntax
* File input/output
* Control flow statements
* Functions

# RStudio 

## RStudio window

<div style="float: center; height: 600px">
  <img src="./Lecture2-figure/RStudio_window.png", height="600", width="950"></img> 
</div>



## RStudio preferences


<div style="float: center; height: 600px">
  <img src="./Lecture2-figure/RStudio_preferences.png", height="600", width="950"></img> 
</div>



## RStudio layout

<div style="float: center; height: 600px">
  <img src="./Lecture2-figure/RStudio_layout.png", height="600", width="950"></img> 
</div>



## RStudio apprearance

<div style="float: center; height: 600px">
  <img src="./Lecture2-figure/RStudio_appearances.png", height="600", width="950"></img> 
</div>


## R document types

<div style="float: center; height: 600px">
  <img src="./Lecture2-figure/RStudio_documents.png", height="600", width="950"></img> 
</div>



## R document types

- [R Script](https://cran.r-project.org/doc/contrib/Lemon-kickstart/kr_scrpt.html) **a text file** 
containing R commands stored together.

- [R Markdown](http://rmarkdown.rstudio.com/lesson-1.html)
files can generate high quality reports contatining notes, code and code outputs.
**Python and bash code ** can also be executed.

- [R Notebook](http://rmarkdown.rstudio.com/r_notebooks.html) is 
an R Markdown document with **chunks that can be executed independently and 
interactively**, with output visible immediately beneath the input.

- [R presentation](https://support.rstudio.com/hc/en-us/articles/200486468-Authoring-R-Presentations) 
let's you author **slides** that make use of R code and LaTeX equations 
as **straightforward** as possible.

- [R Sweave](https://support.rstudio.com/hc/en-us/articles/200552056-Using-Sweave-and-knitr) 
enables the embedding of **R code within LaTeX documents**.


## R Notebook

<br/>

Keyboard shortcuts:

- Insert a new code chunk: **Ctrl + Alt + I** (Mac OS: **Cnd + Option + I**)

- Run the current chunk: **Ctrl + Shift + Enter** (Mac OS: **Cmd + Shift + Enter**) 

- Run the current statement (the line where the cursor is) **Ctrl + Enter** 
(Mac OS: **Cmd + Enter**) 


# Syntax

## Style Guide

* There are two main style conventions used in R:
    + [Hadley Wickam style](http://adv-r.had.co.nz/Style.html)
    + [Google R style](https://google.github.io/styleguide/Rguide.xml)
* You can use either of the two style guides or create your own customized style.
* But you should stay **consistent**, e.g. if you choose to assign variables 
with `<-`, stick to it and don't use `=`.



## Identifiers 

<div class="left", style="width: 50%">

**Google Convention:** No underscores ( _ ) or hyphens ( - ) in identifiers. 
Variable names all with lower case letters; words separated with dots 
('variable.name'), but 'variableName' is also accepted;
*function names* have initial capital letters and no dots 
('FunctionName'). Function names should be verbs. Constants are named like 
functions but with an initial k.

```{r, eval = FALSE}
# Good
avg.clicks            # variable name
CalculateAvgClicks    # function name
# Bad
avg_Clicks                                    # variable name
calculate_avg_clicks , calculateAvgClicks     # function name
```

</div>

<div class="right", style="width: 50%">

**Hadley Convention:**Variable and function names should be lowercase. 
Use an underscore (_) to separate words within a name. Generally, 
variable names should be nouns and function names should be verbs. 
Strive for names that are concise and meaningful (this is not easy!). 

```{r eval = FALSE}
# Good
day_one
day_1

# Bad
first_day_of_the_month
DayOne
dayone
djm1
```
</div>


## Spacing

- Place spaces around all infix operators (=, +, -, <-, etc.). 
Exception (Google): Spaces around ='s are optional when passing parameters
in a function call.

- Always put a space after a comma, and never before (just like in regular English).

- Place a space before left parentheses, except in a function call.

```{r eval = FALSE}
# Good
average <- mean(feet / 12 + inches, na.rm = TRUE)
if (debug) do(x)
plot(x, y)
if (debug) do(x)
diamonds[5, ]

# Bad
average<-mean(feet/12+inches,na.rm=TRUE)
if(debug)do(x)
plot (x, y)
if ( debug ) do(x)  # No spaces around debug
x[1,]   # Needs a space after the comma
x[1 ,]  # Space goes after comma not before
```


## 

<div class="left", style="width: 50%">

**Comments:** 
- Comment your code. Each line of a comment should begin with the comment 
symbol and a single space: `# `. Comments should explain the why, not the what.
- Use commented lines of - and = to break up your file into easily readable chunks.


**Curly braces:**
-  An opening curly brace `{` should never go on its own line and should 
always be followed by a new line. 
- A closing curly `}` brace should always go on its own line, unless it’s 
followed by else.
- Always indent the code inside curly braces.
- It’s ok to leave very short statements on the same line


</div>

<div class="right", style="width: 50%">

```{r, eval = FALSE}
# Load data ---------------------------
load("data.rda")
# Plot data ---------------------------
plot(x, y)
```


```{r eval = FALSE}
# Good
if (y < 0 && debug) {
  message("Y is negative")
}
if (y == 0) {
  log(x)
} else {
  y ^ x
}

# Bad
if (y < 0 && debug)
message("Y is negative")

if (y == 0) {
  log(x)
} 
else {
  y ^ x
}
```

```{r eval = FALSE}
if (y < 0 && debug) message("Y is negative")
```
</div>


# File Input/Output


## Working Directory

<div class="left", style="width: 50%">

- The **current working directory** (cmd) is the location
which R is currently pointing to

- Whenever you try to read or save a file without specifying 
the path explicitly, the cmd will be used by default.

- When are executing code from an R markdown/notebook code chunk, 
the cmd is **the location of the document**.

</div>

<div class="right", style="width: 50%">

- To see the current working directory use `getwd()`:
```{r}
getwd()   # with no arguments
```

- To change the working directory use `setwd(path_name)` 
with a specified path as na argument:
```{r eval = FALSE}
setwd("path/to/directory")
```
</div>


## Data import 

<div class="left", style="width: 50%">

Reading **text files** into R is fairly simple.

- **Text Files in a table format** can be read and saved 
to a selected variable using a `read.table()` function.

- Use `?read.table` to learn about the function arguments.

- A common text file format is a **comma delimited text file**,
`.csv`. These files use a comma as column separators, e.g:

```{r eval = FALSE}
Year,Student,Major
2009, John Doe,Statistics
2009, Bart Simpson, Mathematics I
```


</div>

<div class="right", style="width: 50%">

- To read these files use the following command:

```{r eval=FALSE}
# In Windows you might need to use \ instead of the / when specifying the path
mydata <- read.table("path/to/filename.csv", header=TRUE,  sep=",")
```

- `header = TRUE` is used when the row in the file contains 
variable id's/names not actual values.

- The `sep` argument (with white space as default),
specifies the separator used in the file. For comma-deliminated
files set `sep = ","`, and for tab-deliminated, `sep = "\t"`.

- You can optionally use `row.names` or `col.names` arguments
to set the row and column names.

```{r eval = FALSE}
# read.csv() has covenient argument defaults for '.csv' files
mydata <- read.csv("path/to/filename.csv")
```

</div>


## Data import 

- **Excel files**. To read the excel files you need
to first install a package "xlsx". Simply run 
`install.packages("xlsx")`.

```{r eval = FALSE}
# first row contains variable names
library(xlsx)
mydata <- read.xlsx("path/to/filename.xlsx", 1)  # read the first worksheet

# read in the worksheet named mysheet
mydata <- read.xlsx("path/to/filename.xlsx", sheetName = "mysheet")
```

- **SAS files**. You need to install `Hmisc` or `foreign` 
packages first.

```{r eval = FALSE}
# First, save your SAS dataset in trasport (xport) format
libname out xport 'path/to/filename.xpt';
data out.mydata;
set sasuser.mydata;
run;

# Then, in R 
library(Hmisc)
mydata <- sasxport.get("path/to/filename.xpt")
# character variables are converted to R factors
# or
library(foreign)
mydata <- read.xport("path/to/filename.xpt")
```


## Data export

Saving/writing data to a file is also easy.

- **Text files**:
```{r eval = FALSE}
write.table(mydata, "path/to/filename.txt", sep="\t")      # tab-delimited
write.table(mydata, "path/to/filename.csv", sep=",")       # comma-delimited
write.csv(mydata, "path/to/filename.csv")                  # comma-delimited
```

- **Excel spreadsheet**:

```{r eval = FALSE}
library(xlsx)
write.xlsx(mydata, "path/to/filename.xlsx")
```

- **SAS** files:
```{r eval = FALSE}
# write out text datafile and an SAS program to read it
library(foreign)
write.foreign(mydata, datafile = "path/to/filename.txt", 
              codefile = "path/to/filename.sas",  package="SAS")
```


## Saving the workspace

- You can choose to **save all objects** currently in the workspace
(variables, functions, etc.) into a file e.g. `filename.rda`.

- The file `filename.rda` can be loaded next time you work with R.

- You can also save a single object or a subset of specified
objects currently in the workspace.

```{r eval = FALSE}
# save the workspace to file 
save.image(file = "path/to/filename.rda")

# save specific objects to a file
save(object_list, file = "path/to/filename.rda")

# save just a single object
saveRDS(object, file = "path/to/filename.rds")
```

- Saved objects/workspace can be loaded back in a new R session.

```{r eval = FALSE}
# load a workspace into the current session
load("path/to/filenamerda")

# read just the previously saved 1 object
object <- readRDS("path/to/filename.rds")
```


## Practice

Some of the material in this section was taken from 
[here](http://www.statmethods.net/input/importingdata.html),
[here](http://www.statmethods.net/input/exportingdata.html), 
and [here](http://www.statmethods.net/interface/workspace.html),
where you can look up more details.

**Exercise 1**

- Download "Lec2_ex.Rmd" from the class website
under Lectures tab.

- Open the file in RStudio.

- Do Exercise 1.


# Control flow

# Booleans/logicals

<div class="left", style="width: 50%">

- **Booleans** are logical data types (TRUE/FALSE) associated
with conditional statements, which allow different actions 
and change control flow.

```{r}
# equals: ==
5 == 5
# does not equal: != 
5 != 5 
# greater than: >
5 > 4 
# greater than or equal: >= (# similarly < and <=)
5 >= 5

# You can **combine multiple boolean expressions**
TRUE & TRUE
TRUE & FALSE 
TRUE | FALSE
!(TRUE)
```


</div>

<div class="right", style="width: 50%">

- In R if you combine 2 vectors of booleans,
by each element then use `&`. Rember the **recycling property** for vectors.

```{r}
c(TRUE, TRUE) & c(FALSE, TRUE)
c(5 < 4, 7 == 0, 1< 2) | c(5==5, 6> 2, !FALSE)
c(TRUE, TRUE) & c(TRUE, FALSE, TRUE, FALSE)  # recycling
```

- If we use double operators `&&` or `||` is used only the first 
elements are compared:

```{r}
c(TRUE, TRUE) && c(FALSE, TRUE)
c(5 < 4, 7 == 0, 1< 2) || c(5==5, 6> 2, !FALSE)
c(TRUE, TRUE) && c(TRUE, FALSE, TRUE, FALSE)
```

</div>


## Booleans/logicals

- Another possibility to combine booleans is to use
`all()` or `any()` functions:

```{r}
all(c(TRUE, FALSE, TRUE))
any(c(TRUE, FALSE, TRUE))
all(c(5 > -1, 3 >= 1, 1 < 1))
any(c(5 > -1, 3 >= 1, 1 < 1))
```



## Control statements

* **Control flow** is the order in which individual statements, 
instructions or function calls of an imperative program are 
executed or evaluated.

* Control statements allow you to do more complicated tasks.

* Their execution results in a choice between which of 
two or more paths should be followed.
    + `If` / `else`
    + `For`
    + `While`


## If statements

<div class="left", style="width: 50%">

- Decide on whether a block of code should be executed
based on the associated boolean expression.
</br>

```{r eval = FALSE}
if (traffic_light == "green") {
  print("Go.")
}
```

- 'if-else' statements let you introduce more options

```{r eval = FALSE}
if (traffic_light == "green") {
   print("Go.")
} else {
   print("Stay.")
}
```


</div>

<div class="right", style="width: 50%">

- You can also use `else if()`

```{r eval = FALSE}
if (traffic_light == "green") {
   print("Go.")
} else if (traffic_light == "yellow") {
  print("Get ready.")
} else {
   print("Stay.")
}
```

- **Note the syntax**. The if statements are followed by
a boolean expression wrapped in parenthesis (adding white space is
a good practice). The conditional block of code is inside curly
braces `{}`.

</div>


## For loops

- Foor loop is a statement specifying iterations, 
which allows for a block of code to be **execuded repeatedly**
(a given number of times).

```{r}
for (i in 1:5){
  print(i^2)
}
```

- Again note the curly braces syntax!


## While loops

</br>

- Similar to for loops, but repeat the execution 
as long as the boolean condition supplied is TRUE.

```{r}
i = 1
while(i <= 5) {
  cat("i =", i, "\n")
  i = i + 1
}
```



## Next

- `next` halts the processing of the current iteration 
and advances the looping index. 

- `next` apply only to the innermost of nested loops.

```{r}
for (i in 1:10) {
  if (i <= 5) {
    print("skip")
    next
  }
  cat(i, "is greater than 5.\n")
}
```


## Break

- The `break` statement allows us to break out out of a for, 
while loop (of the smallest enclosing).
- The control is transferred to the first statement outside 
the inner-most loop. 

```{r}
for (n in 2:10) {
  for (k in 2:n) {
    if (n %% k == 0) {                   # n divisible by x
      cat(n, "equals", k, "*", n/k, "\n")
      break                              # do not check divisibility by other numbers
    } else {                             # executed if no break in for loop
      cat(n, "is a prime number. \n")    # loop fell through without finding a factor
    }
  }
}
```


## Exercise 2

</br>

- Go back to "Lec2_ex.Rmd" in RStudio.

- Do Exercise 2.


## Functions

## Functions

- A **functions** is a procedure/routine that performs a specific task.

- Functions are used to **abstract** components of larger program.

- They are like a mathematical functions. They **take some input 
and then do something to find the result**.

- Functions allow you to **automate common tasks** in a more powerful 
and general way than copy-and-pasting. You should *use a function, 
whenever you’ve copied and pasted a block of code more than twice*.



## Function Definition

<div class="left", style="width: 50%">

- To define a function you assigne a variable name 
to a `function` object.

- Functions take **arguments, mandatory and optional**.

- Provide the brief **description of your function in comments**
before the function definition.


</div>

<div class="right", style="width: 50%">

```{r}
# function example - computes measures of central tendency
# and spread for a numeric vector x. The user has a
# choice of measures and whether the results are printed.
mysummary <- function(x, npar=TRUE, print=TRUE) {
  if (!npar) {
    center <- mean(x); spread <- sd(x) 
  } else {
    center <- median(x); spread <- mad(x) # Median Absolute Deviation (MAD)
  }
  if (print & !npar) {
    cat("Mean =", center, "\n", "SD=", spread, "\n")
  } else if (print & npar) {
    cat("Median =", center, "\n", "MAD=", spread, "\n")
  }
  result <- list(center=center,spread=spread)
  return(result)
}
```
</div>


## Calling functions

<div class="left", style="width: 50%">
- Invoking the function 
```{r}
set.seed(1234)
x <- rnorm(n = 500, mean = 4, sd = 1) 
y <- mysummary(x)
y$center 
y$spread 
```

</div>

<div class="right", style="width: 50%">

```{r}
# without printing
y <- mysummary(x, npar=FALSE, print=FALSE)
y$center
y$spread

# The order of arguments does not matter if the names are specified
y <- mysummary(npar=FALSE, x, print=FALSE)
y <- mysummary(npar=FALSE, print=FALSE, x = x)
```
</div>


## Exercise 3

</br>

- Go back to "Lec2_ex.Rmd" in RStudio.

- Do Exercise 3.


## apply, lapply, sapply functions

- "apply" family functions (in R base package), are 
**functions to manipulate slices of data** from matrices, 
arrays, lists and dataframes in a repetitive way. 

- These functions **avoid explicit use of loops**. 
Using apply might be computationally more efficient then
for loops, depending on how big your data is.
For more details check out this 
[link](https://www.r-bloggers.com/gnu-r-loop-speed-comparison/).

- They **apply a named function** with one or several 
optional arguments. 

- The apply functions help you perform operations with 
**very few lines of code.**

- The family comprises: **apply, lapply , sapply, vapply, 
mapply, rapply, and tapply** (the use depend on the structure
of input data and the desired format of the output).


## lapply/sapply functions

<div class="left", style="width: 50%">

- If we would like to **repeatedly apply a function to 
a elements of a list**, we should use `lapply()`.

- `lapply` can also be used for other objects like 
**dataframes, lists or vectors**.

- The output returned is a list which has the same number of elements as
the input object.

- `sapply` is the same as `lapply` but returns a "simplified" output.

- user-defined functions and extra arguments work for `sapply/lapply`
just as for `apply`.

</div>

<div class="right", style="width: 50%">

```{r}
lapply(1:3, function(x) x^2)
unlist(lapply(1:3, function(x) x^2))
sapply(1:3, function(x) x^2)
sapply(1:3, function(x) x^2, simplify = F)
```

</div>

## apply function

`apply` operates on arrays/matrices. The function call
for apply function is of the form `apply(X, MARGIN, FUN, ...)` where:

- X is an array/matrix 
- MARGIN is a vector giving the subscripts which the function will be applied 
over. 
- FUN is the function to be applied (including the user-defined ones)

In the example below we obtain the sums of the columns.
```{r}
set.seed(12345)
(X <- matrix(rnorm(30), nrow = 5, ncol = 6))
apply(X, 2 ,sum)
```

**Note:** that in a matrix `MARGIN=1` indicates rows and `MARGIN=2`
indicates columns.

## apply function

- `apply` can be used with **user-defined functions**:
<font size="5">
```{r}
print(X)
apply(X, 2, function(x) length(x[x < 0])) # number of negative entries
```

- Alternatively, the function can be defined outside `apply()`,
which is useful for more complicated functions. Note **extra arguments**
can be supplied to apply.

```{r}
myFun <- function(x, base = NULL) {
  if (!is.null(base)) x <- x + base
  return(length(x[x < 0]))
}
apply(X, 2, myFun) 
apply(X, 2, myFun, base = 0.2) 
```



## mapply functions

<div class="right", style="width: 50%">

- `mapply` stands for 'multivariate' apply. 
- It **applies a function
to a multiple list or multiple vectors as arguments**. 
- The goal is to vectorize arguments to a function which usually 
does not accept vectors as arguments. 

```{r}
# function word() returns a string of character C repeated k times.
word <- function(C,k) paste(rep.int(C,k), collapse='')
mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
```

</div>

<div class="right", style="width: 50%">

`mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)`

- FUN	- function to apply, found via match.fun.
- ...	- arguments to vectorize over.
- MoreArgs - a list of other arguments to FUN.
- SIMPLIFY - logical or character string; attempt to reduce the result to 
a vector, matrix or higher dimensional array
- USE.NAMES	- logical; use names if the first ... argument has names, or if it
is a character vector, use that character vector as the names.

</div>


## Exercise 4

</br>

- Go back to "Lec2_ex.Rmd" in RStudio.

- Do Exercise 4.

