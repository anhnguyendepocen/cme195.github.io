---
title: "Homework 2"
author: "Lan Huong Nguyen"
date: "October 25, 2017"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
```


# Exercise 1: `ggplot`[20pt]

The following url:
"http://cdiac.ess-dive.lbl.gov/ftp/ndp030/CSV-FILES/nation.1751_2014.csv"
contains data on fossil fuel emissions.

a. Read data to R. Note that rows 1-3 contain information on the dataset itself.
Delete these rows as they do not contain relevant information.

```{r}
emissions <- read.csv("http://cdiac.ess-dive.lbl.gov/ftp/ndp030/CSV-FILES/nation.1751_2014.csv",
                      stringsAsFactors = FALSE)
emissions <- emissions[4:nrow(emissions), ]
head(emissions)
```

b. Compute the total yearly $CO_2$ emissions (column "Total.CO2.emissions.from.fossil.fuels.and.cement.production..thousand.metric.tons.of.C.") 
summed over all countries (the world total $CO_2$ emission). 
You can use a forloop over "years" or `dplyr` functions.

```{r message=FALSE, warning = FALSE}
library(dplyr)
emissionsTotal <- emissions %>% 
  group_by(Year) %>%
  summarise(
    world_total = 
      sum(Total.CO2.emissions.from.fossil.fuels.and.cement.production..thousand.metric.tons.of.C.))
```


c. Plot the world (summed over all countries) $CO_2$ emission over time in 
billion tonnes (Gt) per year, i.e. divide the quantity
computed in (b) by 10^6. You can use a line or a scatter plot.

```{r message=FALSE, warning = FALSE}
library(ggplot2)
ggplot(emissionsTotal, aes(x = Year, y = world_total/10^6)) +
  geom_line() + theme_classic()
```

d. Now read the dataset located at "https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv" which contains an assignment of countries to regions. Merge emissions
dataset to the countries dataset. Note that in emissions dataset countries are
given with all caps, but not in countries dataset. You need to change that before
merging the two tables. Hint: use the function `toupper()`. Add a column
'co2_emission' equal to $CO_2$ emission in Gt, i.e. 
'Total.CO2.emissions.from.fossil.fuels.and.cement.production..thousand.metric.tons.of.C.'/10^6

```{r}
countries <- read.csv("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv",
                      stringsAsFactors = FALSE)
countries$NAME <- toupper(countries$name)
head(countries)
```

We can look for inconsistencies in the countries names, by inspecting
the countries names that where not in both data frames:

```{r}
(not_in_emissions <- setdiff(countries$NAME, emissions$Nation))
```


```{r}
(not_in_countries <- setdiff(emissions$Nation, countries$NAME))
```

Now, for each 'Nation' in emissions that is not in the 'countries' data-frame
we find the country with the closest 'NAME' using `agrep()` function for
approximate string matching.

```{r}
names_in_countries_idx <- sapply(not_in_emissions, function(x) agrep(x, emissions$Nation)[1])
names_in_emissions_idx <- sapply(not_in_countries, function(x) agrep(x, countries$NAME)[1])

countries_names_to_change <- data.frame(
  name_in_countries = c(not_in_emissions, countries$NAME[names_in_emissions_idx]),
  names_in_emissions = c(emissions$Nation[names_in_countries_idx], not_in_countries),
  stringsAsFactors = FALSE) %>%
  filter(!is.na(name_in_countries), !is.na(names_in_emissions))
countries_names_to_change
```

We see that two matching did not work: 
AUSTRALIA --> USSR, and BONAIRE, SINT EUSTATIUS AND SABA--> SABAH

So we drop them:
```{r}
countries_names_to_change <- countries_names_to_change %>%
  filter(!name_in_countries %in% c("AUSTRALIA", "BONAIRE, SINT EUSTATIUS AND SABA"))
```

Now, we change the original names in 'countries' to new names:

```{r}
countries$NAME  <- sapply(countries$NAME, function(x) {
  if(x %in% countries_names_to_change$name_in_countries) {
    idx <- grep(x, countries_names_to_change$name_in_countries)[1]
    x <- countries_names_to_change$names_in_emissions[idx]
  }
  return(x)
})
```



```{r}
df <- emissions %>% 
  left_join(countries, by = c("Nation" = "NAME")) %>%
  mutate(co2_emission = Total.CO2.emissions.from.fossil.fuels.and.cement.production..thousand.metric.tons.of.C./10^6)
df$sub.region[df$sub.region == ""] <- NA
head(df)
```

e. Use `dplyr` to compute total annual $CO_2$ ('co2_emission') 
emission per 'sub.region'.


```{r}
df <- df %>%
  group_by(Year, sub.region) %>%
  summarise(co2_emission = sum(co2_emission))
head(df)
```


f. Use `ggplot` to generate a stacked density plot the annual $CO_2$ 
(in giga tonnes) by world regions ("sub.region").
Your plot should resemble something like this (but with other regional 
categories, and slightly different values). Hint: use `geom_area()`
function with suitable parameters. Which region seems to produce most
$CO_2$? You might like to modify the color scheme to better distinguish
regions.

![Source: https://ourworldindata.org/grapher/annual-co-emissions-by-region](./annual-co-emissions-by-region.png)


```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
library(RColorBrewer)
set.seed(89475)
cols <- sample(colorRampPalette(brewer.pal(12, "Set3"))(23))
ggplot(df, aes(x = Year, y = co2_emission)) +
  geom_area(aes(fill = sub.region), position = "stack") +
  scale_fill_manual(na.value = "grey50", values = cols) +
  theme_classic() + theme(legend.position = "bottom") 
```


# Exercise 2: Gene expression data [20pt]

In this exercise we will use the DNA microarray gene expression data.
You can read more about it on page 5 of 
["The Elements of Statistical Learning"](https://web.stanford.edu/~hastie/Papers/ESLII.pdf).

```{r}
microarray <- read.table("https://web.stanford.edu/~hastie/ElemStatLearn/datasets/nci.data")
info <- read.table("https://web.stanford.edu/~hastie/ElemStatLearn/datasets/nci.info.txt",
                   skip = 12)
colnames(microarray) <- info$V1
microarray[1:5, 1:5]
```

In the 'microarray' matrix columns correspond to samples, and rows to genes.

a. Subset microarray to 500 most variable genes, i.e. the ones with the highest 
standard deviation across samples (you shoud use `order()` to find the indices). 
Then, plot a heatmap without clustering/dendrograms. You can use 'asp = 0.2' 
argument to change the aspect ratio of the heatmap.

```{r, fig.width=8, fig.height=10}
idx <- order(apply(microarray,1, sd), decreasing = TRUE)[1:500]
heatmap(as.matrix(microarray)[idx, ], Rowv = NA, 
        Colv = NA, asp=0.2, scale = "none")
```

b. Plot the previous heatmap with red/green color scheme. For your convenience
here is the color vector you might like to use:
```{r }
redgreen <- c("#FF0000", "#DB0000", "#B60000", "#920000", "#6D0000",
              "#490000", "#240000", "#000000", "#002400", "#004900",
              "#006D00", "#009200", "#00B600", "#00DB00", "#00FF00")
```


```{r fig.width=8, fig.height=10}
heatmap(as.matrix(microarray)[idx, ], Rowv = NA, Colv = NA, asp=0.2, 
        col = redgreen, scale = "none")
```

Now, plot the same graph but with dendrogram for rows (rows clustering).

```{r fig.width=12, fig.height=10}
heatmap(as.matrix(microarray)[idx, ], Colv = NA, asp=0.2, 
        col = redgreen, scale = "none")
```

d. Now instead of base heatmap, use interactive `heatmaply()` to generate the 
previous plot. You might want to add a command similar to the following 
` %>% layout(margin = list(l = 150, b = 350), autosize = F, width = 600, height = 800)`
to the plot to set margins and to resize it. 


```{r, message=FALSE, warning = FALSE, fig.height=12, fig.width=10}
library(heatmaply)
heatmaply(data.frame(microarray[idx, ]), Colv = FALSE, colors = redgreen,
          scale = "none", margin = list(l = 150, b = 600), 
          width = 800, height = 1000, autosize = FALSE) 
```


e. What interesting patterns do you observe? Are there
some differences between conditions? Are some genes up down regulated
for certain groups? No need for long answers just look at the heatmap
state what you see.

It seems like certain groups of patients have sertain groups of genes
up or down regulated, specifically melanoma and colon cacer patients
seem to have certain "blocks of green", which means that specific group
of genes have increased expression in these type of patients.

# Exercise 3: Hypothesis testing [10pt]

Recall the movies data-frame we used in for lecture 3 exercises. It contains
information on movies from the last three decates, which was scrapped from
the IMDB database.

```{r}
url <- "https://raw.githubusercontent.com/Juanets/movie-stats/master/movies.csv"
movies <- tbl_df(read.csv(url))
movies
```

a. Generate a boxplot of runtimes for action movies and commedies
with jittered points overlaid on top. You might consider setting collor, 
fill and alpha arguments to modify clarity and transparency of the plot.

```{r, fig.height=4, fig.width=4}
ggplot(movies %>% filter(genre %in% c("Action", "Comedy")), 
       aes(x = genre, y = runtime)) +
  geom_jitter(height = 0,alpha = 0.2, color = "grey30") +
  geom_boxplot(lwd = 1, color = "darkgreen", fill = NA) +
  theme_classic()
```

b. Test a hypothesis that the action movies have higher mean runtime (length)
than the comedies. Is the difference statistically greater than zero
at significance level $\alpha = 0.05$?

```{r}
t.test(formula = runtime ~ genre,
       data = movies %>% 
         filter(genre %in% c("Action", "Comedy")), 
       alternative = "greater")
```

Yes, the test showed that there is enough eveidence to reject the null
hypothesis, and the action movies have higher mean length than the comedies.

# Exercise 4: linear model [20pt]

a. Read the data from "http://www-bcf.usc.edu/~gareth/ISL/Advertising.csv"
containing information on sales of a product and the amount spent on advertising
using different media channels.

```{r}
advertising <- read.csv("http://www-bcf.usc.edu/~gareth/ISL/Advertising.csv", 
                        row.names = 1)
head(advertising)
```

b. Generate a scatterplot of sales against the amount of TV advertising and 
add a linear fit line.

```{r}
ggplot(advertising, aes(x = TV, y = sales)) +
  geom_point() + geom_smooth(method = "lm") +
  theme_classic()
```

c. Now make a 3D scatterplot with axes corresponding to 'sales', 'TV'
and 'radio'.

```{r, message = FALSE, warning=FALSE}
library(plotly)
plot_ly(data = advertising, x = ~TV, y = ~radio, z = ~sales, 
        type = "scatter3d", mode = "markers", marker = list(size = 4))
```


d. The dataset has 200 rows. Divide it into a train set with 150 observations
and a test set with 50 observations, i.e. use `sample(1:200, n = 150)` to
randomly choose row indices of the advertising dataset to include in the 
train set. The remaining indices should be used for the test set. Remember
to choose and set the seed for randomization!

```{r}
set.seed(12345)
idx <- sample(1:nrow(advertising), 150)
train <- advertising[idx, ]
test <- advertising[-idx, ]
```


e. Fit a linear model to the training set, where the sales values are
predicted by the amount of TV advertising. Print the summary of the fitted model.
Then, predict the sales values for the test set and evaluate the test model 
accuracy in terms of root mean squared error (MSE), which measures 
the average level of error between the prediction and the true response.

$$RMSE = \sqrt{\frac{1}{n} \sum\limits_{i = 1}^n(\hat y_i - y_i)^2}$$

```{r}
fit1 <- lm(sales ~ TV, data  = train)
summary(fit1)
```

```{r}
yhat <- predict(fit1, test)
(rmse1 <- sqrt(mean((test$sales - yhat)^2)))
```

f. Fit a multiple linerar regression model including all the variables 'TV',
'radio', 'newspaper' to model the 'sales' in the training set. Then, compute 
the predicted sales for the test set with the new model and evalued the RMSE.  
Did the error decrease from the one correspodning to the previous model?

```{r}
fit2 <- lm(sales ~ TV + radio + newspaper, data  = train)
summary(fit2)
```

```{r}
yhat <- predict(fit2, test)
(rmse2 <- sqrt(mean((test$sales - yhat)^2)))
```

The new model seems to improve the prediction, by decresing the test error. 

g. Look at the summary output for the multiple regression model and note which 
of the coefficient in the model is significant. Are all of them significant?
If not refit the model including only the features found significant.
Which of the models should you choose? 

```{r}
fit3 <- lm(sales ~ TV + radio, data  = train)
summary(fit3)
```

```{r}
yhat <- predict(fit3, test)
(rmse3 <- sqrt(mean((test$sales - yhat)^2)))
```

The last model has a slightly lower test error, but not by much.
However, it contains fewer variables, so as a simpler model should be 
preferable.


# Exercise 5: classification [20pt]

We load the following datsets including characteristics of emails
and spams:

* 48 continuous real [0,100] attributes of type 

`word_freq_WORD = percentage of words in the e-mail that match WORD.

* 6 continuous real [0,100] attributes of type 

`char_freq_CHAR` = percentage of characters in the e-mail that match CHAR,

* 1 continuous real [1,...] attribute of type 
`capital_run_length_average`  = average length of uninterrupted sequences of capital letters

* 1 continuous integer [1,...] attribute of type 

`capital_run_length_longest` = length of longest uninterrupted sequence of capital letters

* 1 continuous integer [1,...] attribute of type 

`capital_run_length_total` = sum of length of uninterrupted sequences of capital letters = 
 = total number of capital letters in the e-mail

* 1 nominal {0,1} class attribute of type 

`spam` = denotes whether the e-mail was considered spam (1) or not (0), 

```{r}
url.info <- "https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.names"
spam.info <- read.table(url.info, comment.char = "|", skip = 32, stringsAsFactors = FALSE)
attributes <- gsub(":", "", spam.info[[1]])
attributes[49: 54]
symbols <- c("semicolon", "left.parenthesis", "left.sq.bracket", "exclamation", 
             "dollar", "hashtag")
attributes[49: 54] <- paste0("char_freq_", symbols)
attributes[49: 54] 
```


```{r}
url.data <- "https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.data"
spam <- read.csv(url.data, header = FALSE, stringsAsFactors = FALSE)
colnames(spam) <- c(attributes, "spam")
spam <- spam %>%
  mutate(spam  = factor(spam, levels = c(0, 1), labels = c("email", "spam")))
head(spam)
```

a. Check if the dataset contains balance classes spam vs email. To
do this count the cases of spam and email, and make a barplot for
the frequencies.

```{r}
table(spam$spam)
```


```{r, fig.width = 5, fig.height=5}
ggplot(spam, aes(x = spam)) + geom_bar() +
  theme_classic()
```

b. Divide the data into train and test set with a 60%-40% split. Remember 
to record the seed you used for randomization.

```{r}
set.seed(27846)
train.idx <- sample(nrow(spam), 0.6*nrow(spam))
train <- spam[train.idx, ]
test <- spam[-train.idx, ]
```

c. Use logistic regression involving all the predictors to train a model
for classifying emails. Which features seem significant?
Evaluate and report your model's accuracy on the test set.

```{r}
spam.logit <- glm(spam ~ ., train, family = "binomial")
summary(spam.logit)
```


```{r}
spam.prob.logit <- predict(spam.logit, test, type = "response")
spam.pred.logit <- factor(spam.prob.logit < 0.5, levels = c(TRUE, FALSE),
                          labels = c("email", "spam"))
(conf.mat.logit <- table(pred = spam.pred.logit, true = test$spam))
(accuracy.logit <- sum(diag(conf.mat.logit))/nrow(test))
```

```{r, echo = FALSE}
logit.coef.spam <- coefficients(summary(spam.logit))
```


There were 20  features
coefficients significant at level $\alpha = 0.05$. The logistic model seems to 
work well with accuracy `r accuracy.logit`.

d. Use random forest to train a model on the same train set. Report which
variables have high importance scores. Then, evaluate the RF model's 
accuracy on the test set.

```{r, message=FALSE, warning=FALSE}
library(randomForest)
spam.rf <- randomForest(spam ~ ., data = train, importance = TRUE)
spam.rf
```

```{r, fig.width=10, fig.height=8}
varImpPlot(spam.rf)
```

```{r}
mean.decrese.accuracy <- importance(spam.rf) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("feature") %>%
  select(feature, MeanDecreaseAccuracy) %>%
  arrange(desc(MeanDecreaseAccuracy))
mean.decrese.accuracy
```

```{r}
mean.decrese.gini <- importance(spam.rf) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("feature") %>%
  select(feature, MeanDecreaseGini) %>%
  arrange(desc(MeanDecreaseGini))
mean.decrese.gini
```

```{r}
intersect(mean.decrese.accuracy$feature[1:10], mean.decrese.gini$feature[1:10])
```


The variable importance measures indicate that explamation marks, and dollar
signs, as well as the frequency of words such as "free", "remove", "hp",
"your" as well as the length of sequences of capital letters are predictive
of whether a piece of text is a spam.

```{r}
spam.pred.rf <- predict(spam.rf, test)
(conf.mat.rf <- table(pred = spam.pred.rf, true = test$spam))
(accuracy.rf <- sum(diag(conf.mat.rf))/nrow(test))
```

It seems like the random forest has a slight edge compared to the logistic
regression model, with test accuracy of 0.95 vs 0.93.
In general, for easy problems, random forest performs well as a black box 
predictor without much tuning or a prior variable selection.


# Exercise 6: `ggmap` [10pt]

a. Consider the two following locations:
`from <-  c(lon = -122.169719, lat = 37.4274745)`
and `to <- c(lon = -122.16242, loc = 37.44457)`. Create a vector
for the bounding box of the two locations 
`bbox <- c(left = longitude.from, bottom = latitude.from, 
right = longitude.to, top = latitude.to)` with appropriate values filled in.
Then, use the `get_map()` and `ggmap` to generate a map containing the two 
locations. Use source: "google", maptype = "satellite" and a city-level-zoom,
zoom = 15. 

```{r, message=FALSE, warning = FALSE}
library(ggmap)
from <-  c(lon = -122.169719, lat = 37.4274745)
to <- c(lon = -122.16242, loc = 37.44457) 
bbox <- c(left = from[[1]], bottom = from[[2]], 
         right = to[[1]], top = to[[2]])

myMap <- get_map(location = bbox, crop = TRUE, zoom = 15, 
                 source = "google", maptype="satellite")
map <- ggmap(myMap)
map
```


c. Use the function `route()` from the `ggmap` to generate a data-frame 
corresponding to the route from one location to the other. 
Then, use `geom_path()` to add the path corresponding to the
route generated with the `route()` function. You can use a function
`revgeocode()` to look up the addresses of the `from` and `to` locations.


```{r, message=FALSE, warning = FALSE}
route_df <- route(from, to, structure = "route")
map <- map + 
  geom_path(data = route_df, 
    aes(x = lon, y = lat), colour = "red", size = 1.5)
map
```

```{r, warning=FALSE, message=FALSE}
revgeocode(from)
revgeocode(to)
```

You just mapped a route from Stanford to the only pub in town!

d. In this exercise we will generate a map of San Francisco and include the 
information on the housing prices. The dataset with housing prices
can be downloaded from github as follows:

```{r}
url.housing <- "https://raw.githubusercontent.com/simonkassel/Visualizing_SF_home_prices_R/master/Data/SF_home_sales_demo_data.csv"
sf.housing <- read.csv(url.housing, row.names = 1)
head(sf.housing)
```

Use `get_map()` and `ggmap()` to plot a map of San Francisco using
source = "google", maptype = "toner-lite" and zoom = 13. Then,
use the data on housing prices above to add a layer of points
colored by the SalePrice (use a good color scheme).

```{r warning=FALSE, message=FALSE}
library(viridis)
sf.map.data <- get_map(location = geocode("San Francisco"), 
                       zoom = 13, maptype = "toner-lite")
sf.map <- ggmap(sf.map.data) 
(sf.map <- sf.map + 
  geom_point(data = sf.housing, aes(color =  SalePrice, x = long, y = lat)) +
  scale_color_viridis())
```

```{r}
sessionInfo()
```
