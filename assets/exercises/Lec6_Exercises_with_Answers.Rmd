---
title: "Lecture 6: Exercises with answers"
date: October 19th, 2017
output: 
  html_notebook:
    toc: true
    toc_float: true
---


The flights dataset
Now we can perform a similar analysis on the flights dataset.

What affects the number of daily flights?

daily <- flights %>% 
  mutate(date = make_date(year, month, day)) %>% 
  group_by(date) %>% summarise(n = n())
daily
## # A tibble: 365 x 2
##    date           n
##    <date>     <int>
##  1 2013-01-01   842
##  2 2013-01-02   943
##  3 2013-01-03   914
##  4 2013-01-04   915
##  5 2013-01-05   720
##  6 2013-01-06   832
##  7 2013-01-07   933
##  8 2013-01-08   899
##  9 2013-01-09   902
## 10 2013-01-10   932
## # ... with 355 more rows
ggplot(daily, aes(date, n)) + 
  geom_line()
  
Day of the week
Let’s start by looking at the distribution of flight numbers by day-of-week:

daily <- daily %>% mutate(wday = wday(date, label = TRUE))
ggplot(daily, aes(wday, n)) + geom_boxplot()
There are fewer flights on weekends because most travel is for business.

How can we remove this pattern?


Modelling the day of the week
We try to remove this strong pattern using a model.

mod   <- lm(n ~ wday, data = daily)
grid  <- daily %>% data_grid(wday) %>%  add_predictions(mod, "n")
daily <- daily %>% add_residuals(mod)




Our model fails starting in June: weekly pattern still visible
There are some days with far fewer flights than expected
There is some smoother long term trend over the course of a year

Seasonal Saturday effect
Let’s try to understand the residual weekly pattern in Summer and Fall.

ggplot(daily, aes(date, resid, color = wday)) + 
  geom_ref_line(h = 0) + geom_line()

daily %>% filter(wday == "Sat") %>% 
  ggplot(aes(date, n)) + geom_point() + geom_line() +
    scale_x_date(NULL, date_breaks = "1 month", date_labels = "%b")




There is a strong seasonal effect on Saturday flights. Holidays?


Identifying seasonal effects
Let’s create a “term” variable that roughly captures the three school terms.

daily <- daily %>% 
  mutate(term = cut(date, 
    breaks = ymd("2013-01-01","2013-06-05","2013-08-25","2014-01-01"),
    labels = c("spring", "summer", "fall") ) )  
daily %>% 
  filter(wday == "Sat") %>% 
  ggplot(aes(date, n, 
             color=term)) +
  geom_point(alpha = 1/3) + 
  geom_line() +
  scale_x_date(NULL,
    date_breaks="1 month",
    date_labels = "%b")


The dates were tweaked to get nice breaks in the plot.

Seasonal and weekly effects
Let’s see how the term affects the days of the week

ggplot(daily, aes(x=wday, y=n, color=term)) + geom_boxplot()


Now fitting a separate day of week effect for each term seems reasonable.

mod2 <- lm(n ~ wday * term, data = daily)

Modeling for seasonal and weekly effects
mod1 <- lm(n ~ wday, data = daily)
mod2 <- lm(n ~ wday * term, data = daily)
This improves our model, but not as much as we might hope

daily %>% gather_residuals(without_term = mod1, with_term = mod2) %>% 
  ggplot(aes(date, resid, color = model)) + geom_line(alpha = 0.75)


We should overlay the predictions from the model on to the raw data.


Visualizing the predictions
grid <- daily %>% 
  data_grid(wday, term) %>% add_predictions(mod2, "n")
ggplot(daily, aes(wday, n)) + geom_boxplot() + 
  geom_point(data = grid, color = "red") + facet_wrap(~ term)
  
  ur model is finding the mean effect, but we have a lot of big outliers.


Fitting a robust linear regression
mod3 <- MASS::rlm(n ~ wday * term, data = daily)

daily %>% 
  add_residuals(mod3, "resid") %>% 
  ggplot(aes(date, resid)) + 
  geom_hline(yintercept = 0, size = 2, color = "white") + 
  geom_line()
  
  Identifying the outliers
Can we explain the remaining large residuals?

daily %>% add_residuals(mod3, "resid") %>% 
  filter(abs(resid) > 100)
  
  Many correspond to US public holidays.

Long-term trend
We can still see some smooth long term trend.

daily %>% 
  add_residuals(mod3, "resid") %>% filter(abs(resid) < 100) %>%
  ggplot(aes(date, resid)) + geom_ref_line(h = 0) + 
  geom_line(color = "grey50") + geom_smooth(se = FALSE, span = 0.20)

We can’t do much with this pattern quantitatively, because we only have a single year of data



# Exercise 1: Hypothesis testing

Similarly to dataset `mtcars`, the dataset `mpg` from `ggplot` package 
includes data on automobiles. However, `mpg` includes data for newer
cars from year 1999 and 2008. The variables measured for each car is slighly 
different. Here we are interested in the variable, `hwy`, the highway miles per 
gallon.


```{r}
library(ggplot2)
library(dplyr)

mpg
# We create a new culumn with manual/automatic data only
mpg <- mpg %>% 
  mutate(
    transmission = factor(gsub("\\((.*)", "", trans), levels = c("auto", "manual"))
  )
mpg
```

## Part 2: One-sample test

a. Subset the `mpg` dataset to inlude only cars from  year 2008.

```{r}
mpg2008 <- mpg %>% 
  filter(year == 2008)
```

b. Test whether cars from 2008 have mean the highway miles per gallon, `hwy`, 
equal to 30 mpg.

```{r}
t.test(mpg2008$hwy, mu = 30, alternative = "two.sided")
```

c. Test whether cars from 2008 with 4 cylinders have mean `hwy` equal to 30 mpg.

```{r}
mpg2008_4cyl <- mpg %>% 
  filter(year == 2008, cyl == 4)

t.test(mpg2008_4cyl$hwy, mu = 30, alternative = "two.sided")
```

## Part 2: Two-sample test

a. Test if the mean `hwy` for automatic is **less than** that for manual cars
**in 2008**. Generate a boxplot with jittered points for `hwy` for each 
transmission group.

```{r}
t.test(data = mpg2008, hwy ~ transmission, alternative = "less")
# or
# t.test(x = mpg2008 %>% filter(transmission == "auto") %>% pull(hwy),
#        y = mpg2008 %>% filter(transmission == "manual") %>% pull(hwy), 
#        alternative = "less")
```

```{r}
ggplot(mpg2008, aes(x = transmission, y = hwy)) +
  geom_boxplot() + geom_jitter(height = 0, width = 0.2)
```

b. Test if the mean `hwy` for cars from 1999 and is greater than that for
cars from 2008. Generate a boxplot with jittered points
for `hwy` for each year group.

```{r}
t.test(data = mpg, hwy ~ year, alternative = "greater")
```

```{r}
ggplot(mpg, aes(x = factor(year), y = hwy)) +
  geom_boxplot() + geom_jitter(height = 0, width = 0.2)
```


# Exercise 2: Linear Regression

## Part 1

The data in the following URL "http://www-bcf.usc.edu/~gareth/ISL/Income1.csv"
includes observation on income levels (in tens of thousands of dollars)
and years of education. *The data is not real and was actually simulated*.

a. Read the data into R.
```{r}
income <- read.csv("http://www-bcf.usc.edu/~gareth/ISL/Income1.csv", row.names = 1)
income
```
b. Generate a ggplot with a fitted line.

```{r}
library(ggplot2)
ggplot(income, aes(x = Education, y = Income)) +
  geom_point() + geom_smooth(method = "lm")
```


c. Fit a linear model with education as input variable and income as response 
variable. Then, print the model summary

```{r}
fit <- lm(data = income, formula = Income ~ Education)
summary(fit)
```


d. Print out just the model coefficients.

```{r}
coef(fit)
```

d. Print out the predicted values of income for the observations
included in the dataset.

```{r}
predict(fit)
```


e. Predict the income for new observations, for people with 
16.00, 12.52, 15.55, 21.09, and 18.36 years of education.

```{r}
predict(fit, data.frame(Education = c(16.00, 12.52, 15.55, 21.09, 18.36)))
```


## Part 2

a. Now download data from "http://www-bcf.usc.edu/~gareth/ISL/Income2.csv"
which include the same observations but also records data on "senority".

```{r}
income2 <- read.csv("http://www-bcf.usc.edu/~gareth/ISL/Income2.csv", row.names = 1)
income2
```

b. Fit a new model including a new variable and print the model summary.

```{r}
mfit <- lm(data = income2, formula = Income ~ Education + Seniority)
summary(mfit)
```

c. Print the predicted values of income for the existing observations.

```{r}
predict(mfit)
```


d. Predict the income levels for new observations with years of education
equal to 16.00, 12.52, 15.55, 21.09, 18.36 and seniority to
123.74, 83.63,  90.94, 178.96, 125.17.

```{r}
newobs <- data.frame(Education = c(16.00, 12.52, 15.55, 21.09, 18.36),
                     Seniority = c(123.74, 83.63,  90.94, 178.96, 125.17))
predict(mfit, newobs)
```

