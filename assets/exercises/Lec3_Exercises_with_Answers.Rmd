---
title: "Lecture 3: Exercises with Answers"
date: October 10th, 2017
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r global_options, echo = FALSE, include = FALSE}
options(width = 80)
knitr::opts_chunk$set(warning = FALSE, message = FALSE,
                      cache = FALSE, tidy = FALSE, size = "small")
library(dplyr)
```

# Execise 1: Apply family functions

## Part 1
Below we print six first rows of the built-in dataset, `mtcars`, 
from the 1974 Motor Trend US magazine, which comprises information
on the fuel consumption and 10 aspects of automobile design 
and performance for 32 selected car models. 

```{r}
head(mtcars)
```

Use `apply()` function to find the standard deviation and the 0.8-quantile  
of each of the automobile characteristic.

```{r}
apply(mtcars, 2, function(x) sd(x))
```


```{r}
apply(mtcars, 2, function(x) { quantile(x, 0.8)})
```

## Part 2

Below is a vector of dates in year 2017.

```{r}
set.seed(1234)
y2017 <- seq(as.Date("2017-01-01", format = "%Y-%m-%d"), 
             as.Date("2017-12-31", format = "%Y-%m-%d"), 
             "days")
# Shuffle days of the year randomly
y2017.shuffled <- sample(y2017)
length(y2017.shuffled)
```

Use an `apply` family function to return the number of weeks
left from each day in `y2017.shuffled` to the New Year, 2018/01/01.

```{r}
ny2018 <- as.Date("2018-01-01", format = "%Y-%m-%d")
weeks.to.2018 <- sapply(y2017.shuffled, function(d) ceiling((ny2018 - d)/7))
names(weeks.to.2018) <- y2017.shuffled
weeks.to.2018[1:5]
```


# Execise 2: Data manipulation

## Part 1: `dplyr` verbs

Load in the dataset `movies.csv` used in the lecture:

```{r}
library(dplyr)
url <- "https://raw.githubusercontent.com/Juanets/movie-stats/master/movies.csv"
movies <- tbl_df(read.csv(url))
movies
```


a. Find a subset of the movies produced after 2010. 
Save the subset in 'movies.sub' variable.

```{r}
movies.sub <- filter(movies, year > 2010)
movies.sub
```

b. Keep columns 'name', 'director', 'year', 'country', 'genre', 'budget', 'gross', 'score'
in the 'movies.sub'.

```{r}
movies.sub <- select(movies.sub, name, director, year, country, genre, budget, gross, score)
movies.sub
```

c. Find the profit for each movie in 'movies.sub' as a fraction of its budget.
Convert 'budget' and 'gross' columns million dollar units founded to the first decimal point.
Use `round()` to round numbers.

```{r}
movies.sub <- mutate(movies.sub, 
                     frac_profit = (gross - budget)/budget,
                     budget = round(budget/10^6, digits = 1),
                     gross = round(gross/10^6, digits = 1))
movies.sub
```


d. Count the number of movies in 'movies.sub' produced by each genre,
and order them in the descending count order.

```{r}
by_genre <- group_by(movies.sub, genre)
arrange(summarise(by_genre, count = n()), desc(count))
```

e. Now group movies in 'movies.sub' by countries and genre.
Then, count the number of movies in each group and the corresponding 
median fractional profit, the mean and standard deviation of 
the movie score for each group.

```{r}
movies.summary <- movies.sub %>%
  group_by(genre, country) %>%
  summarise(count = n(), 
            median_profit = median(frac_profit),
            mean_score = mean(score), 
            sd_score = sd(score)) %>%
  filter(count > 10) %>%
  arrange(desc(mean_score))
movies.summary
```


## Part 2: Chaining

Using chaining and pipes, for each genre find the three directors the
top mean movie scores received for the movies produced after 2000,
after filtering out the directors with fewer than 5 movies in total.
Hint: Use `top_n()` function to select top n from each group.

```{r}
top5_dir <- movies %>% 
  filter(year > 2000) %>%
  group_by(genre, director) %>%
  summarise(
    mean_score = mean(score),
    count = n()) %>%
  filter(count >= 3) %>%
  group_by(genre) %>%
  top_n(5, wt = mean_score)
top5_dir
```

Pick your favourite genre and the top 3 directors to find movie recommendations
for your next movie night!

```{r}
class(top5_dir)
```

See that `top5_dir` has a class 'grouped_df', so we convert it to 
a data frame first.
```{r}
topDramaDir <- top5_dir %>% 
  as_data_frame() %>%
  filter(genre == "Drama") %>% 
  select(director)

```

```{r}
movies %>% 
  filter(genre == "Drama", 
         director %in% topDramaDir[["director"]]) %>%
  select(name, director, year, score, genre, gross, budget) %>%
  arrange(desc(score))
```

## Part 3: Merging

Consider the two data-frames below:

```{r}
elections <- data.frame(
  year = rep(c(2016, 2012, 2008, 2004, 2000), each = 2),
  name = c("Hillary Clinton", "Donald Trump", "Barack Obama", "Mitt Romney",
           "Barack Obama", "John McCain", "John Kerry", "George W. Bush",
           "Al Gore", "George W. Bush"),
  party = rep(c("Democratic", "Republican"), 5),
  state = c("NY", "NY", "IL", "MA", "IL", "AZ", "MA", "TX", "TN", "TX"),
  stringsAsFactors = FALSE
)
elections
```

```{r}
personal <- data.frame(
  name = c("Hillary Clinton", "Donald Trump", "Barack Obama", "Mitt Romney",
           "John McCain", "George W. Bush"),
  spouse = c("Bill Clinton", "Melania Knauss", "Michelle Robinson", "Ann Davies",
             "Cindy Hensley", "Laura Welch"),
  year = c(1975, 2005, 1992, 1969, 1980, 1977),
  children = c(1, 5, 2, 5, 7, 2), stringsAsFactors = FALSE
)
personal
```

a. Merge the two data tables so that you have all the entries from dataset 
'election' but for each candidate you have personal information added.

Merge 'personal' to 'elections' the two data tables using `left_join()`

```{r}
elections %>% left_join(personal)
```

Observe what happened to the "year" columns.

Note also, that this did not quite get a reasonable result as `left_join()`
by default merges two tables by ALL shared variables, so in this case
"name" AND "year". However, "year" in two data-frames here mean two different 
things, one is the election year and the other is the year married.
What we really want is to **merge by** "name" only.

```{r}
# Note that you need to use QUOTATION marks
elections %>% left_join(personal, by = "name")
```

We can do the reverse operatio and merge 'elections' to 'personal':

```{r}
# Note that this gives you fewer rows:
personal %>% left_join(elections, by = "name")
```

b. Imagine that you have two data-frames where the columns you want to merge
by do not share the same name like in the example below. Try to merge
the two datasets now, by using appropriate input arguments to `left_join()`.

```{r}
elections <- data.frame(
  year = rep(c(2016, 2012, 2008, 2004, 2000), each = 2),
  candidate = c("Hillary Clinton", "Donald Trump", "Barack Obama", "Mitt Romney",
           "Barack Obama", "John McCain", "John Kerry", "George W. Bush",
           "Al Gore", "George W. Bush"),
  party = rep(c("Democratic", "Republican"), 5),
  state = c("NY", "NY", "IL", "MA", "IL", "AZ", "MA", "TX", "TN", "TX")
)
elections
```

```{r}
personal <- data.frame(
  name = c("Hillary Clinton", "Donald Trump", "Barack Obama", "Mitt Romney",
           "John McCain", "George W. Bush"),
  spouse = c("Bill Clinton", "Melania Knauss", "Michelle Robinson", "Ann Davies",
             "Cindy Hensley", "Laura Welch"),
  year = c(1975, 2005, 1992, 1969, 1980, 1977),
  children = c(1, 5, 2, 5, 7, 2)
)
personal
```

```{r}
elections %>% left_join(personal, by = c("candidate" = "name"))
```


